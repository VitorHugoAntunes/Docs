---
id: algoritmos-casamento-estavel
title: Algoritmos de Casamento EstÃ¡vel  
slug: algoritmos-casamento-estavel
category: Algoritmos AvanÃ§ados
description: Aprenda sobre algoritmos de casamento estÃ¡vel, incluindo Gale-Shapley, casamento bipartido e suas aplicaÃ§Ãµes prÃ¡ticas.
order: 3
---

# Algoritmos de Casamento EstÃ¡vel

Aprenda sobre algoritmos de casamento estÃ¡vel, incluindo Gale-Shapley, casamento bipartido e suas aplicaÃ§Ãµes prÃ¡ticas.

## DefiniÃ§Ã£o

Um casamento estÃ¡vel Ã© uma correspondÃªncia entre dois conjuntos de elementos onde nÃ£o existem pares que prefeririam estar casados entre si em vez de com seus parceiros atuais. O problema clÃ¡ssico envolve encontrar um casamento estÃ¡vel entre homens e mulheres baseado em suas preferÃªncias.

### Conceitos Fundamentais:

- **Casamento (Matching):** CorrespondÃªncia um-para-um entre elementos de dois conjuntos
- **PreferÃªncia:** OrdenaÃ§Ã£o dos elementos do conjunto oposto por cada elemento
- **Par Bloqueante:** Dois elementos que preferem um ao outro mais que seus parceiros atuais
- **Estabilidade:** AusÃªncia de pares bloqueantes no casamento
- **Casamento Ã“timo:** Melhor casamento possÃ­vel para um dos lados

### Propriedades:
- **ExistÃªncia:** Sempre existe pelo menos um casamento estÃ¡vel
- **Unicidade:** Pode haver mÃºltiplos casamentos estÃ¡veis
- **Otimalidade:** O algoritmo Gale-Shapley produz o melhor casamento para o lado que propÃµe

## Algoritmo Gale-Shapley

O algoritmo Gale-Shapley encontra um casamento estÃ¡vel atravÃ©s de um processo iterativo de propostas e rejeiÃ§Ãµes.

### ImplementaÃ§Ã£o Completa em C:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_PESSOAS 100

// Estrutura para representar preferÃªncias
typedef struct {
    int preferencias[MAX_PESSOAS][MAX_PESSOAS];  // Matriz de preferÃªncias
    int ranking[MAX_PESSOAS][MAX_PESSOAS];       // Ranking inverso para busca rÃ¡pida
    int numPessoas;                              // NÃºmero de pessoas em cada lado
    char nomes[MAX_PESSOAS][50];                 // Nomes para facilitar visualizaÃ§Ã£o
} SistemaPreferencias;

// Estrutura para o estado do algoritmo
typedef struct {
    int casamentosHomens[MAX_PESSOAS];   // casamentosHomens[i] = mulher casada com homem i (-1 se solteiro)
    int casamentosMulheres[MAX_PESSOAS]; // casamentosMulheres[i] = homem casado com mulher i (-1 se solteira)
    int proximaProposta[MAX_PESSOAS];    // PrÃ³xima mulher para cada homem propor
    bool homemLivre[MAX_PESSOAS];        // Status de liberdade dos homens
    int numHomensLivres;                 // Contador de homens livres
} EstadoCasamento;

// Inicializa o sistema de preferÃªncias
SistemaPreferencias* criarSistemaPreferencias(int numPessoas) {
    SistemaPreferencias* sistema = (SistemaPreferencias*)malloc(sizeof(SistemaPreferencias));
    sistema->numPessoas = numPessoas;
    
    // Inicializa arrays
    for (int i = 0; i < numPessoas; i++) {
        sprintf(sistema->nomes[i], "Pessoa%d", i);
        for (int j = 0; j < numPessoas; j++) {
            sistema->preferencias[i][j] = -1;
            sistema->ranking[i][j] = -1;
        }
    }
    
    return sistema;
}

// Define nomes para as pessoas
void definirNomes(SistemaPreferencias* sistema, char nomes[][50], int lado) {
    for (int i = 0; i < sistema->numPessoas; i++) {
        strcpy(sistema->nomes[i + (lado * sistema->numPessoas)], nomes[i]);
    }
}

// Define as preferÃªncias de uma pessoa
void definirPreferencias(SistemaPreferencias* sistema, int pessoa, int preferencias[], int lado) {
    int offset = lado * sistema->numPessoas;
    pessoa += offset;
    
    for (int i = 0; i < sistema->numPessoas; i++) {
        int preferido = preferencias[i] + ((1 - lado) * sistema->numPessoas);
        sistema->preferencias[pessoa][i] = preferido;
        sistema->ranking[pessoa][preferido] = i;  // Ranking inverso
    }
}

// Inicializa o estado do casamento
EstadoCasamento* inicializarEstado(int numPessoas) {
    EstadoCasamento* estado = (EstadoCasamento*)malloc(sizeof(EstadoCasamento));
    
    for (int i = 0; i < numPessoas; i++) {
        estado->casamentosHomens[i] = -1;
        estado->casamentosMulheres[i] = -1;
        estado->proximaProposta[i] = 0;
        estado->homemLivre[i] = true;
    }
    
    estado->numHomensLivres = numPessoas;
    return estado;
}

// Verifica se uma mulher prefere o novo pretendente ao atual parceiro
bool mulherPreferePretendente(SistemaPreferencias* sistema, int mulher, int pretendente, int atual) {
    int mulherOffset = sistema->numPessoas;
    int rankingPretendente = sistema->ranking[mulher + mulherOffset][pretendente];
    int rankingAtual = sistema->ranking[mulher + mulherOffset][atual];
    
    return rankingPretendente < rankingAtual;
}

// Imprime o estado atual do casamento
void imprimirEstadoCasamento(SistemaPreferencias* sistema, EstadoCasamento* estado, int iteracao) {
    printf("\n=== IteraÃ§Ã£o %d ===\n", iteracao);
    printf("Casamentos atuais:\n");
    
    for (int i = 0; i < sistema->numPessoas; i++) {
        if (estado->casamentosHomens[i] != -1) {
            printf("  %s â†” %s\n", 
                   sistema->nomes[i], 
                   sistema->nomes[estado->casamentosHomens[i] + sistema->numPessoas]);
        }
    }
    
    printf("Homens livres: ");
    bool primeiro = true;
    for (int i = 0; i < sistema->numPessoas; i++) {
        if (estado->homemLivre[i]) {
            if (!primeiro) printf(", ");
            printf("%s", sistema->nomes[i]);
            primeiro = false;
        }
    }
    if (primeiro) printf("Nenhum");
    printf("\n");
}

// Algoritmo Gale-Shapley
EstadoCasamento* galeShapley(SistemaPreferencias* sistema) {
    EstadoCasamento* estado = inicializarEstado(sistema->numPessoas);
    int iteracao = 0;
    
    printf("=== ExecuÃ§Ã£o do Algoritmo Gale-Shapley ===\n");
    printf("Os homens fazem propostas Ã s mulheres baseadas em suas preferÃªncias.\n");
    
    while (estado->numHomensLivres > 0) {
        iteracao++;
        
        // Encontra um homem livre
        int homem = -1;
        for (int i = 0; i < sistema->numPessoas; i++) {
            if (estado->homemLivre[i]) {
                homem = i;
                break;
            }
        }
        
        // Encontra a prÃ³xima mulher na lista de preferÃªncias do homem
        int mulher = sistema->preferencias[homem][estado->proximaProposta[homem]] - sistema->numPessoas;
        estado->proximaProposta[homem]++;
        
        printf("\nIteraÃ§Ã£o %d: %s propÃµe para %s\n", 
               iteracao, sistema->nomes[homem], sistema->nomes[mulher + sistema->numPessoas]);
        
        if (estado->casamentosMulheres[mulher] == -1) {
            // Mulher estÃ¡ livre - aceita a proposta
            estado->casamentosHomens[homem] = mulher;
            estado->casamentosMulheres[mulher] = homem;
            estado->homemLivre[homem] = false;
            estado->numHomensLivres--;
            
            printf("  %s aceita! Eles estÃ£o noivos.\n", sistema->nomes[mulher + sistema->numPessoas]);
        } else {
            // Mulher jÃ¡ estÃ¡ comprometida - verifica preferÃªncia
            int parceirAtual = estado->casamentosMulheres[mulher];
            
            if (mulherPreferePretendente(sistema, mulher, homem, parceirAtual)) {
                // Mulher prefere o novo pretendente
                estado->casamentosHomens[parceirAtual] = -1;
                estado->homemLivre[parceirAtual] = true;
                estado->numHomensLivres++;
                
                estado->casamentosHomens[homem] = mulher;
                estado->casamentosMulheres[mulher] = homem;
                estado->homemLivre[homem] = false;
                estado->numHomensLivres--;
                
                printf("  %s prefere %s a %s. Ela troca de parceiro.\n", 
                       sistema->nomes[mulher + sistema->numPessoas],
                       sistema->nomes[homem],
                       sistema->nomes[parceirAtual]);
                printf("  %s fica livre novamente.\n", sistema->nomes[parceirAtual]);
            } else {
                // Mulher prefere o parceiro atual
                printf("  %s prefere seu parceiro atual %s. Proposta rejeitada.\n", 
                       sistema->nomes[mulher + sistema->numPessoas],
                       sistema->nomes[parceirAtual]);
            }
        }
        
        // Imprime estado a cada iteraÃ§Ã£o (opcional para problemas pequenos)
        if (sistema->numPessoas <= 5) {
            imprimirEstadoCasamento(sistema, estado, iteracao);
        }
    }
    
    printf("\n=== Algoritmo Finalizado ===\n");
    return estado;
}

// Verifica se o casamento Ã© estÃ¡vel
bool verificarEstabilidade(SistemaPreferencias* sistema, EstadoCasamento* estado) {
    printf("\n=== VerificaÃ§Ã£o de Estabilidade ===\n");
    bool estavel = true;
    
    for (int homem = 0; homem < sistema->numPessoas; homem++) {
        for (int mulher = 0; mulher < sistema->numPessoas; mulher++) {
            int parceirHomem = estado->casamentosHomens[homem];
            int parceirMulher = estado->casamentosMulheres[mulher];
            
            // Verifica se este homem e mulher formariam um par bloqueante
            bool homemPrefereMulher = sistema->ranking[homem][mulher + sistema->numPessoas] < 
                                     sistema->ranking[homem][parceirHomem + sistema->numPessoas];
            bool mulherPrefereHomem = sistema->ranking[mulher + sistema->numPessoas][homem] < 
                                     sistema->ranking[mulher + sistema->numPessoas][parceirMulher];
            
            if (homemPrefereMulher && mulherPrefereHomem) {
                printf("PAR BLOQUEANTE ENCONTRADO: %s e %s se preferem aos seus parceiros atuais!\n",
                       sistema->nomes[homem], sistema->nomes[mulher + sistema->numPessoas]);
                estavel = false;
            }
        }
    }
    
    if (estavel) {
        printf("âœ“ O casamento Ã© ESTÃVEL - nÃ£o hÃ¡ pares bloqueantes.\n");
    }
    
    return estavel;
}

// Calcula satisfaÃ§Ã£o mÃ©dia dos homens e mulheres
void calcularSatisfacao(SistemaPreferencias* sistema, EstadoCasamento* estado) {
    printf("\n=== AnÃ¡lise de SatisfaÃ§Ã£o ===\n");
    
    double satisfacaoHomens = 0.0;
    double satisfacaoMulheres = 0.0;
    
    printf("SatisfaÃ§Ã£o individual (quanto menor, melhor):\n");
    printf("Homens:\n");
    for (int i = 0; i < sistema->numPessoas; i++) {
        int parceira = estado->casamentosHomens[i];
        int ranking = sistema->ranking[i][parceira + sistema->numPessoas];
        satisfacaoHomens += ranking + 1; // +1 para comeÃ§ar do 1 em vez de 0
        printf("  %s (casado com %s): posiÃ§Ã£o %d na sua lista\n", 
               sistema->nomes[i], 
               sistema->nomes[parceira + sistema->numPessoas], 
               ranking + 1);
    }
    
    printf("Mulheres:\n");
    for (int i = 0; i < sistema->numPessoas; i++) {
        int parceiro = estado->casamentosMulheres[i];
        int ranking = sistema->ranking[i + sistema->numPessoas][parceiro];
        satisfacaoMulheres += ranking + 1;
        printf("  %s (casada com %s): posiÃ§Ã£o %d na sua lista\n", 
               sistema->nomes[i + sistema->numPessoas], 
               sistema->nomes[parceiro], 
               ranking + 1);
    }
    
    satisfacaoHomens /= sistema->numPessoas;
    satisfacaoMulheres /= sistema->numPessoas;
    
    printf("\nSatisfaÃ§Ã£o mÃ©dia:\n");
    printf("  Homens: %.2f\n", satisfacaoHomens);
    printf("  Mulheres: %.2f\n", satisfacaoMulheres);
    
    if (satisfacaoHomens < satisfacaoMulheres) {
        printf("  â†’ Os homens estÃ£o mais satisfeitos (algoritmo otimiza para quem propÃµe)\n");
    } else if (satisfacaoMulheres < satisfacaoHomens) {
        printf("  â†’ As mulheres estÃ£o mais satisfeitas\n");
    } else {
        printf("  â†’ SatisfaÃ§Ã£o equilibrada\n");
    }
}

// Imprime as preferÃªncias de forma organizada
void imprimirPreferencias(SistemaPreferencias* sistema) {
    printf("\n=== PreferÃªncias ===\n");
    
    printf("PreferÃªncias dos Homens:\n");
    for (int i = 0; i < sistema->numPessoas; i++) {
        printf("  %s: ", sistema->nomes[i]);
        for (int j = 0; j < sistema->numPessoas; j++) {
            if (j > 0) printf(" > ");
            printf("%s", sistema->nomes[sistema->preferencias[i][j]]);
        }
        printf("\n");
    }
    
    printf("\nPreferÃªncias das Mulheres:\n");
    for (int i = 0; i < sistema->numPessoas; i++) {
        printf("  %s: ", sistema->nomes[i + sistema->numPessoas]);
        for (int j = 0; j < sistema->numPessoas; j++) {
            if (j > 0) printf(" > ");
            printf("%s", sistema->nomes[sistema->preferencias[i + sistema->numPessoas][j]]);
        }
        printf("\n");
    }
}

// Imprime o casamento final
void imprimirCasamentoFinal(SistemaPreferencias* sistema, EstadoCasamento* estado) {
    printf("\n=== Casamento EstÃ¡vel Final ===\n");
    for (int i = 0; i < sistema->numPessoas; i++) {
        printf("  %s â†” %s\n", 
               sistema->nomes[i], 
               sistema->nomes[estado->casamentosHomens[i] + sistema->numPessoas]);
    }
}
```

Agora vamos criar exemplos de uso do algoritmo:

```c
// FunÃ§Ã£o para criar exemplo clÃ¡ssico do livro
void exemploClassico() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘          EXEMPLO CLÃSSICO              â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    SistemaPreferencias* sistema = criarSistemaPreferencias(4);
    
    // Definir nomes
    char nomesHomens[4][50] = {"Alberto", "Bruno", "Carlos", "Daniel"};
    char nomesMulheres[4][50] = {"Ana", "Beatriz", "Clara", "Diana"};
    
    definirNomes(sistema, nomesHomens, 0);  // 0 = homens
    definirNomes(sistema, nomesMulheres, 1); // 1 = mulheres
    
    // Definir preferÃªncias dos homens (Ã­ndices das mulheres: 0=Ana, 1=Beatriz, 2=Clara, 3=Diana)
    int prefAlberto[] = {0, 1, 2, 3}; // Ana > Beatriz > Clara > Diana
    int prefBruno[] = {1, 0, 2, 3};   // Beatriz > Ana > Clara > Diana
    int prefCarlos[] = {0, 1, 2, 3};  // Ana > Beatriz > Clara > Diana
    int prefDaniel[] = {1, 2, 3, 0};  // Beatriz > Clara > Diana > Ana
    
    definirPreferencias(sistema, 0, prefAlberto, 0);
    definirPreferencias(sistema, 1, prefBruno, 0);
    definirPreferencias(sistema, 2, prefCarlos, 0);
    definirPreferencias(sistema, 3, prefDaniel, 0);
    
    // Definir preferÃªncias das mulheres (Ã­ndices dos homens: 0=Alberto, 1=Bruno, 2=Carlos, 3=Daniel)
    int prefAna[] = {1, 0, 2, 3};     // Bruno > Alberto > Carlos > Daniel
    int prefBeatriz[] = {0, 1, 2, 3}; // Alberto > Bruno > Carlos > Daniel
    int prefClara[] = {1, 2, 0, 3};   // Bruno > Carlos > Alberto > Daniel
    int prefDiana[] = {0, 1, 2, 3};   // Alberto > Bruno > Carlos > Daniel
    
    definirPreferencias(sistema, 0, prefAna, 1);
    definirPreferencias(sistema, 1, prefBeatriz, 1);
    definirPreferencias(sistema, 2, prefClara, 1);
    definirPreferencias(sistema, 3, prefDiana, 1);
    
    imprimirPreferencias(sistema);
    
    EstadoCasamento* resultado = galeShapley(sistema);
    
    imprimirCasamentoFinal(sistema, resultado);
    verificarEstabilidade(sistema, resultado);
    calcularSatisfacao(sistema, resultado);
    
    free(sistema);
    free(resultado);
}

// Exemplo com conflito de interesses
void exemploConflito() {
    printf("\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘       EXEMPLO COM CONFLITO             â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    SistemaPreferencias* sistema = criarSistemaPreferencias(3);
    
    char nomesHomens[3][50] = {"JoÃ£o", "Pedro", "Paulo"};
    char nomesMulheres[3][50] = {"Maria", "Carla", "Sofia"};
    
    definirNomes(sistema, nomesHomens, 0);
    definirNomes(sistema, nomesMulheres, 1);
    
    // Todos os homens preferem Maria, depois Carla, depois Sofia
    int prefHomens[] = {0, 1, 2}; // Maria > Carla > Sofia
    definirPreferencias(sistema, 0, prefHomens, 0);
    definirPreferencias(sistema, 1, prefHomens, 0);
    definirPreferencias(sistema, 2, prefHomens, 0);
    
    // Todas as mulheres preferem Paulo, depois Pedro, depois JoÃ£o
    int prefMulheres[] = {2, 1, 0}; // Paulo > Pedro > JoÃ£o
    definirPreferencias(sistema, 0, prefMulheres, 1);
    definirPreferencias(sistema, 1, prefMulheres, 1);
    definirPreferencias(sistema, 2, prefMulheres, 1);
    
    imprimirPreferencias(sistema);
    
    EstadoCasamento* resultado = galeShapley(sistema);
    
    imprimirCasamentoFinal(sistema, resultado);
    verificarEstabilidade(sistema, resultado);
    calcularSatisfacao(sistema, resultado);
    
    free(sistema);
    free(resultado);
}

// Algoritmo de casamento bipartido mÃ¡ximo (Hungarian Algorithm simplificado)
typedef struct {
    int custos[MAX_PESSOAS][MAX_PESSOAS];
    int atribuicao[MAX_PESSOAS];
    int numTrabalhos, numTrabalhadores;
} ProblemaAtribuicao;

ProblemaAtribuicao* criarProblemaAtribuicao(int numTrabalhadores, int numTrabalhos) {
    ProblemaAtribuicao* problema = (ProblemaAtribuicao*)malloc(sizeof(ProblemaAtribuicao));
    problema->numTrabalhadores = numTrabalhadores;
    problema->numTrabalhos = numTrabalhos;
    
    for (int i = 0; i < numTrabalhadores; i++) {
        problema->atribuicao[i] = -1;
        for (int j = 0; j < numTrabalhos; j++) {
            problema->custos[i][j] = 0;
        }
    }
    
    return problema;
}

// Algoritmo guloso para atribuiÃ§Ã£o de custo mÃ­nimo
int atribuicaoGulosamincara(ProblemaAtribuicao* problema) {
    printf("\n=== Algoritmo de AtribuiÃ§Ã£o Guloso ===\n");
    
    bool trabalhoAtribuido[MAX_PESSOAS] = {false};
    int custoTotal = 0;
    
    for (int rodada = 0; rodada < problema->numTrabalhadores; rodada++) {
        int melhorTrabalhador = -1;
        int melhorTrabalho = -1;
        int menorCusto = INT_MAX;
        
        // Encontra a melhor atribuiÃ§Ã£o disponÃ­vel
        for (int i = 0; i < problema->numTrabalhadores; i++) {
            if (problema->atribuicao[i] == -1) {  // Trabalhador livre
                for (int j = 0; j < problema->numTrabalhos; j++) {
                    if (!trabalhoAtribuido[j] && problema->custos[i][j] < menorCusto) {
                        menorCusto = problema->custos[i][j];
                        melhorTrabalhador = i;
                        melhorTrabalho = j;
                    }
                }
            }
        }
        
        if (melhorTrabalhador != -1) {
            problema->atribuicao[melhorTrabalhador] = melhorTrabalho;
            trabalhoAtribuido[melhorTrabalho] = true;
            custoTotal += menorCusto;
            
            printf("Trabalhador %d â†’ Trabalho %d (custo: %d)\n", 
                   melhorTrabalhador, melhorTrabalho, menorCusto);
        }
    }
    
    return custoTotal;
}

// Exemplo de problema de atribuiÃ§Ã£o
void exemploAtribuicao() {
    printf("\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘       PROBLEMA DE ATRIBUIÃ‡ÃƒO           â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    ProblemaAtribuicao* problema = criarProblemaAtribuicao(4, 4);
    
    // Matriz de custos (trabalhador x trabalho)
    int custos[4][4] = {
        {9, 2, 7, 8},
        {6, 4, 3, 7},
        {5, 8, 1, 8},
        {7, 6, 9, 4}
    };
    
    printf("Matriz de custos (Trabalhador x Trabalho):\n");
    printf("       T0  T1  T2  T3\n");
    for (int i = 0; i < 4; i++) {
        printf("W%d:   ", i);
        for (int j = 0; j < 4; j++) {
            problema->custos[i][j] = custos[i][j];
            printf("%3d ", custos[i][j]);
        }
        printf("\n");
    }
    
    int custoTotal = atribuicaoGulosamincara(problema);
    
    printf("\nAtribuiÃ§Ã£o final (custo total: %d):\n", custoTotal);
    for (int i = 0; i < problema->numTrabalhadores; i++) {
        printf("Trabalhador %d â†’ Trabalho %d\n", i, problema->atribuicao[i]);
    }
    
    free(problema);
}

// FunÃ§Ã£o principal
int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘              ALGORITMOS DE CASAMENTO ESTÃVEL                â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    // Executa os exemplos
    exemploClassico();
    exemploConflito();
    exemploAtribuicao();
    
    printf("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘                       RESUMO TEÃ“RICO                        â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    printf("\nğŸ“Š COMPLEXIDADES:\n");
    printf("â€¢ Gale-Shapley: O(nÂ²) onde n Ã© o nÃºmero de pessoas de cada lado\n");
    printf("â€¢ VerificaÃ§Ã£o de estabilidade: O(nÂ²)\n");
    printf("â€¢ AtribuiÃ§Ã£o gulosa: O(nÂ³)\n");
    
    printf("\nğŸ¯ PROPRIEDADES DO GALE-SHAPLEY:\n");
    printf("â€¢ Sempre produz um casamento estÃ¡vel\n");
    printf("â€¢ Otimiza para o lado que faz as propostas\n");
    printf("â€¢ Ã‰ Ã  prova de estratÃ©gia para quem propÃµe\n");
    printf("â€¢ Produz o casamento Ã³timo para homens e pessimal para mulheres\n");
    
    printf("\nğŸ”„ VARIAÃ‡Ã•ES:\n");
    printf("â€¢ Mulheres propondo: otimiza para as mulheres\n");
    printf("â€¢ Casamento com listas incompletas\n");
    printf("â€¢ Casamento com empates nas preferÃªncias\n");
    printf("â€¢ Casamento many-to-one (hospitais e residentes)\n");
    
    return 0;
}
```

## AnÃ¡lise de Complexidade

### Algoritmo Gale-Shapley:
- **Complexidade de Tempo:** O(nÂ²), onde n Ã© o nÃºmero de pessoas em cada lado
- **Complexidade de EspaÃ§o:** O(nÂ²) para armazenar preferÃªncias e rankings
- **NÃºmero mÃ¡ximo de propostas:** nÂ² - n + 1

### Propriedades Importantes:
1. **TerminaÃ§Ã£o:** O algoritmo sempre termina
2. **Estabilidade:** O resultado Ã© sempre um casamento estÃ¡vel
3. **Otimalidade:** Produz o melhor casamento possÃ­vel para o lado que propÃµe
4. **Unicidade:** Diferentes ordens de propostas podem levar ao mesmo resultado

## VariaÃ§Ãµes e ExtensÃµes

### 1. Casamento com Listas Incompletas
Nem todos precisam classificar todos do outro lado - algumas pessoas podem ser inaceitÃ¡veis.

### 2. Casamento Many-to-One
Hospitais contratando residentes, onde cada hospital pode contratar mÃºltiplos residentes.

### 3. Casamento com Empates
PreferÃªncias podem incluir empates, criando mÃºltiplas soluÃ§Ãµes estÃ¡veis.

### 4. Casamento EgalitÃ¡rio
Minimiza a soma dos rankings de satisfaÃ§Ã£o de ambos os lados.

## AplicaÃ§Ãµes PrÃ¡ticas

### 1. Mercados de Dois Lados
- **NRMP (National Resident Matching Program):** AtribuiÃ§Ã£o de estudantes de medicina a hospitais
- **AdmissÃµes escolares:** AtribuiÃ§Ã£o de estudantes a escolas
- **Mercados de trabalho:** CorrespondÃªncia entre candidatos e empregadores

### 2. AlocaÃ§Ã£o de Recursos
- **AlocaÃ§Ã£o de Ã³rgÃ£os:** DistribuiÃ§Ã£o de Ã³rgÃ£os para transplante
- **AlocaÃ§Ã£o de dormitÃ³rios:** AtribuiÃ§Ã£o de estudantes a quartos
- **DistribuiÃ§Ã£o de turnos:** AtribuiÃ§Ã£o de funcionÃ¡rios a horÃ¡rios

### 3. Problemas EconÃ´micos
- **Mercados de casamento:** Modelagem econÃ´mica de decisÃµes matrimoniais
- **ComÃ©rcio bilateral:** Acordos comerciais entre paÃ­ses
- **Parcerias estratÃ©gicas:** FormaÃ§Ã£o de alianÃ§as empresariais

### 4. Teoria dos Jogos
- **Mecanismos Ã  prova de estratÃ©gia:** Design de sistemas onde nÃ£o compensa mentir
- **EquilÃ­brio de Nash:** SituaÃ§Ãµes onde nenhum jogador quer mudar sua estratÃ©gia
- **Bem-estar social:** MaximizaÃ§Ã£o do benefÃ­cio coletivo

### 5. CiÃªncia da ComputaÃ§Ã£o
- **Balanceamento de carga:** DistribuiÃ§Ã£o de tarefas entre servidores  
- **AlocaÃ§Ã£o de recursos em nuvem:** AtribuiÃ§Ã£o eficiente de recursos computacionais
- **Roteamento em redes:** SeleÃ§Ã£o de caminhos Ã³timos em redes de comunicaÃ§Ã£o

## ConsideraÃ§Ãµes Ã‰ticas e Sociais

### JustiÃ§a vs. EficiÃªncia
O algoritmo Gale-Shapley favorece sistematicamente um lado, levantando questÃµes sobre equidade em aplicaÃ§Ãµes do mundo real.

### TransparÃªncia
Em aplicaÃ§Ãµes prÃ¡ticas, Ã© importante que os participantes entendam como o algoritmo funciona e suas implicaÃ§Ãµes.

### ManipulaÃ§Ã£o
Embora o algoritmo seja Ã  prova de estratÃ©gia para quem propÃµe, o outro lado pode tentar manipular suas preferÃªncias declaradas.