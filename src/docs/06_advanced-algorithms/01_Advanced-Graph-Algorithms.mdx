---
id: algoritmos-grafos-avancados
title: Algoritmos de Grafos Avan√ßados
slug: algoritmos-grafos-avancados
category: Algoritmos Avan√ßados
description: Explore algoritmos avan√ßados de grafos incluindo componentes fortemente conexas, pontes e articula√ß√µes, e colora√ß√£o de grafos.
order: 1
---

# Algoritmos de Grafos Avan√ßados

Explore algoritmos avan√ßados de grafos incluindo componentes fortemente conexas, pontes e articula√ß√µes, e colora√ß√£o de grafos.

## Componentes Fortemente Conexas

Uma componente fortemente conexa √© um subgrafo maximal onde existe um caminho dirigido entre qualquer par de v√©rtices.

### Algoritmo de Tarjan

O algoritmo de Tarjan encontra todas as componentes fortemente conexas em O(V + E).

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_VERTICES 1000

// Estrutura para lista de adjac√™ncia
typedef struct No {
    int vertice;
    struct No* proximo;
} No;

typedef struct {
    No* adjacentes[MAX_VERTICES];
    int numVertices;
} GrafoDirigido;

// Estrutura para pilha
typedef struct {
    int itens[MAX_VERTICES];
    int topo;
} Pilha;

// Estrutura para o algoritmo de Tarjan
typedef struct {
    int low[MAX_VERTICES];          // Menor tempo de descoberta alcan√ß√°vel
    int descoberta[MAX_VERTICES];   // Tempo de descoberta
    bool naPilha[MAX_VERTICES];     // Se o v√©rtice est√° na pilha
    Pilha pilha;                    // Pilha para DFS
    int tempo;                      // Contador de tempo global
    int numComponentes;             // N√∫mero de componentes encontradas
} EstadoTarjan;

// Inicializa grafo dirigido
GrafoDirigido* criarGrafoDirigido(int numVertices) {
    GrafoDirigido* grafo = (GrafoDirigido*)malloc(sizeof(GrafoDirigido));
    grafo->numVertices = numVertices;
    
    for (int i = 0; i < numVertices; i++) {
        grafo->adjacentes[i] = NULL;
    }
    
    return grafo;
}

// Adiciona aresta dirigida
void adicionarArestaDirigida(GrafoDirigido* grafo, int origem, int destino) {
    No* novoNo = (No*)malloc(sizeof(No));
    novoNo->vertice = destino;
    novoNo->proximo = grafo->adjacentes[origem];
    grafo->adjacentes[origem] = novoNo;
}

// Fun√ß√µes da pilha
void inicializarPilha(Pilha* pilha) {
    pilha->topo = -1;
}

void empilhar(Pilha* pilha, int item) {
    pilha->itens[++pilha->topo] = item;
}

int desempilhar(Pilha* pilha) {
    return pilha->itens[pilha->topo--];
}

bool pilhaVazia(Pilha* pilha) {
    return pilha->topo == -1;
}

// Fun√ß√£o auxiliar do algoritmo de Tarjan
void tarjanDFS(GrafoDirigido* grafo, int u, EstadoTarjan* estado) {
    // Define descoberta e low
    estado->descoberta[u] = estado->low[u] = ++estado->tempo;
    empilhar(&estado->pilha, u);
    estado->naPilha[u] = true;
    
    // Percorre todos os adjacentes
    No* atual = grafo->adjacentes[u];
    while (atual != NULL) {
        int v = atual->vertice;
        
        if (estado->descoberta[v] == -1) {
            // Se v n√£o foi visitado, faz DFS recursivo
            tarjanDFS(grafo, v, estado);
            
            // Atualiza low[u] se necess√°rio
            estado->low[u] = (estado->low[v] < estado->low[u]) ? estado->low[v] : estado->low[u];
        } else if (estado->naPilha[v]) {
            // Se v est√° na pilha, atualiza low[u]
            estado->low[u] = (estado->descoberta[v] < estado->low[u]) ? estado->descoberta[v] : estado->low[u];
        }
        
        atual = atual->proximo;
    }
    
    // Se u √© raiz de uma SCC, desempilha todos os v√©rtices da componente
    if (estado->low[u] == estado->descoberta[u]) {
        printf("Componente Fortemente Conexa %d: {", ++estado->numComponentes);
        
        int v;
        bool primeiro = true;
        do {
            v = desempilhar(&estado->pilha);
            estado->naPilha[v] = false;
            
            if (!primeiro) printf(", ");
            printf("%d", v);
            primeiro = false;
        } while (v != u);
        
        printf("}\n");
    }
}

// Algoritmo de Tarjan para encontrar SCCs
void encontrarComponentesFortementeConexas(GrafoDirigido* grafo) {
    EstadoTarjan estado;
    
    // Inicializa estruturas
    inicializarPilha(&estado.pilha);
    estado.tempo = 0;
    estado.numComponentes = 0;
    
    for (int i = 0; i < grafo->numVertices; i++) {
        estado.descoberta[i] = -1;
        estado.low[i] = -1;
        estado.naPilha[i] = false;
    }
    
    printf("=== Encontrando Componentes Fortemente Conexas ===\n");
    
    // Executa DFS para cada v√©rtice n√£o visitado
    for (int i = 0; i < grafo->numVertices; i++) {
        if (estado.descoberta[i] == -1) {
            tarjanDFS(grafo, i, &estado);
        }
    }
    
    printf("Total de componentes encontradas: %d\n\n", estado.numComponentes);
}
```

## Pontes e Articula√ß√µes

Pontes s√£o arestas cuja remo√ß√£o aumenta o n√∫mero de componentes conexas. Articula√ß√µes s√£o v√©rtices com a mesma propriedade.

### Implementa√ß√£o para Encontrar Pontes:

```c
// Estrutura para grafo n√£o-dirigido
typedef struct {
    No* adjacentes[MAX_VERTICES];
    int numVertices;
    int numArestas;
} GrafoNaoDirigido;

// Estado para algoritmo de pontes
typedef struct {
    int descoberta[MAX_VERTICES];
    int low[MAX_VERTICES];
    int pai[MAX_VERTICES];
    bool visitado[MAX_VERTICES];
    int tempo;
    int numPontes;
} EstadoPontes;

// Cria grafo n√£o-dirigido
GrafoNaoDirigido* criarGrafoNaoDirigido(int numVertices) {
    GrafoNaoDirigido* grafo = (GrafoNaoDirigido*)malloc(sizeof(GrafoNaoDirigido));
    grafo->numVertices = numVertices;
    grafo->numArestas = 0;
    
    for (int i = 0; i < numVertices; i++) {
        grafo->adjacentes[i] = NULL;
    }
    
    return grafo;
}

// Adiciona aresta n√£o-dirigida
void adicionarArestaNaoDirigida(GrafoNaoDirigido* grafo, int u, int v) {
    // Adiciona v √† lista de u
    No* novoNo1 = (No*)malloc(sizeof(No));
    novoNo1->vertice = v;
    novoNo1->proximo = grafo->adjacentes[u];
    grafo->adjacentes[u] = novoNo1;
    
    // Adiciona u √† lista de v
    No* novoNo2 = (No*)malloc(sizeof(No));
    novoNo2->vertice = u;
    novoNo2->proximo = grafo->adjacentes[v];
    grafo->adjacentes[v] = novoNo2;
    
    grafo->numArestas++;
}

// Fun√ß√£o auxiliar para encontrar pontes
void pontesDFS(GrafoNaoDirigido* grafo, int u, EstadoPontes* estado) {
    estado->visitado[u] = true;
    estado->descoberta[u] = estado->low[u] = ++estado->tempo;
    
    // Percorre todos os v√©rtices adjacentes
    No* atual = grafo->adjacentes[u];
    while (atual != NULL) {
        int v = atual->vertice;
        
        if (!estado->visitado[v]) {
            estado->pai[v] = u;
            pontesDFS(grafo, v, estado);
            
            // Atualiza low[u]
            estado->low[u] = (estado->low[v] < estado->low[u]) ? estado->low[v] : estado->low[u];
            
            // Se low[v] > descoberta[u], ent√£o (u,v) √© uma ponte
            if (estado->low[v] > estado->descoberta[u]) {
                printf("Ponte encontrada: (%d, %d)\n", u, v);
                estado->numPontes++;
            }
        } else if (v != estado->pai[u]) {
            // Aresta de retorno - atualiza low[u]
            estado->low[u] = (estado->descoberta[v] < estado->low[u]) ? estado->descoberta[v] : estado->low[u];
        }
        
        atual = atual->proximo;
    }
}

// Encontra todas as pontes do grafo
void encontrarPontes(GrafoNaoDirigido* grafo) {
    EstadoPontes estado;
    
    // Inicializa estruturas
    estado.tempo = 0;
    estado.numPontes = 0;
    
    for (int i = 0; i < grafo->numVertices; i++) {
        estado.descoberta[i] = -1;
        estado.low[i] = -1;
        estado.pai[i] = -1;
        estado.visitado[i] = false;
    }
    
    printf("=== Encontrando Pontes ===\n");
    
    // Executa DFS para cada componente conexa
    for (int i = 0; i < grafo->numVertices; i++) {
        if (!estado.visitado[i]) {
            pontesDFS(grafo, i, &estado);
        }
    }
    
    printf("Total de pontes encontradas: %d\n\n", estado.numPontes);
}

// Estado para algoritmo de articula√ß√µes
typedef struct {
    int descoberta[MAX_VERTICES];
    int low[MAX_VERTICES];
    int pai[MAX_VERTICES];
    bool visitado[MAX_VERTICES];
    bool articulacao[MAX_VERTICES];
    int tempo;
    int numArticulacoes;
} EstadoArticulacoes;

// Fun√ß√£o auxiliar para encontrar articula√ß√µes
void articulacoesDFS(GrafoNaoDirigido* grafo, int u, EstadoArticulacoes* estado) {
    int filhos = 0;
    
    estado->visitado[u] = true;
    estado->descoberta[u] = estado->low[u] = ++estado->tempo;
    
    No* atual = grafo->adjacentes[u];
    while (atual != NULL) {
        int v = atual->vertice;
        
        if (!estado->visitado[v]) {
            filhos++;
            estado->pai[v] = u;
            articulacoesDFS(grafo, v, estado);
            
            // Atualiza low[u]
            estado->low[u] = (estado->low[v] < estado->low[u]) ? estado->low[v] : estado->low[u];
            
            // Casos para articula√ß√£o:
            // 1. u √© raiz da DFS e tem mais de um filho
            if (estado->pai[u] == -1 && filhos > 1) {
                estado->articulacao[u] = true;
            }
            
            // 2. u n√£o √© raiz e low[v] >= descoberta[u]
            if (estado->pai[u] != -1 && estado->low[v] >= estado->descoberta[u]) {
                estado->articulacao[u] = true;
            }
        } else if (v != estado->pai[u]) {
            // Aresta de retorno
            estado->low[u] = (estado->descoberta[v] < estado->low[u]) ? estado->descoberta[v] : estado->low[u];
        }
        
        atual = atual->proximo;
    }
}

// Encontra todas as articula√ß√µes do grafo
void encontrarArticulacoes(GrafoNaoDirigido* grafo) {
    EstadoArticulacoes estado;
    
    // Inicializa estruturas
    estado.tempo = 0;
    estado.numArticulacoes = 0;
    
    for (int i = 0; i < grafo->numVertices; i++) {
        estado.descoberta[i] = -1;
        estado.low[i] = -1;
        estado.pai[i] = -1;
        estado.visitado[i] = false;
        estado.articulacao[i] = false;
    }
    
    printf("=== Encontrando Articula√ß√µes ===\n");
    
    // Executa DFS para cada componente conexa
    for (int i = 0; i < grafo->numVertices; i++) {
        if (!estado.visitado[i]) {
            articulacoesDFS(grafo, i, &estado);
        }
    }
    
    printf("Articula√ß√µes encontradas: {");
    bool primeiro = true;
    for (int i = 0; i < grafo->numVertices; i++) {
        if (estado.articulacao[i]) {
            if (!primeiro) printf(", ");
            printf("%d", i);
            estado.numArticulacoes++;
            primeiro = false;
        }
    }
    printf("}\n");
    printf("Total de articula√ß√µes: %d\n\n", estado.numArticulacoes);
}

// Colora√ß√£o de Grafos
typedef struct {
    int cores[MAX_VERTICES];
    int numCores;
    bool usado[MAX_VERTICES];
} EstadoColoracao;

// Algoritmo guloso para colora√ß√£o de grafos
int coloracaoGulosa(GrafoNaoDirigido* grafo) {
    EstadoColoracao estado;
    
    // Inicializa cores
    for (int i = 0; i < grafo->numVertices; i++) {
        estado.cores[i] = -1;
    }
    
    printf("=== Colora√ß√£o Gulosa do Grafo ===\n");
    
    // Atribui cor 0 ao primeiro v√©rtice
    estado.cores[0] = 0;
    estado.numCores = 1;
    
    printf("V√©rtice 0: Cor 0\n");
    
    // Atribui cores aos demais v√©rtices
    for (int u = 1; u < grafo->numVertices; u++) {
        // Marca cores usadas pelos adjacentes
        for (int i = 0; i < grafo->numVertices; i++) {
            estado.usado[i] = false;
        }
        
        No* atual = grafo->adjacentes[u];
        while (atual != NULL) {
            int v = atual->vertice;
            if (estado.cores[v] != -1) {
                estado.usado[estado.cores[v]] = true;
            }
            atual = atual->proximo;
        }
        
        // Encontra a menor cor dispon√≠vel
        int cor;
        for (cor = 0; cor < grafo->numVertices; cor++) {
            if (!estado.usado[cor]) {
                break;
            }
        }
        
        estado.cores[u] = cor;
        if (cor >= estado.numCores) {
            estado.numCores = cor + 1;
        }
        
        printf("V√©rtice %d: Cor %d\n", u, cor);
    }
    
    printf("\nColora√ß√£o completa:\n");
    for (int i = 0; i < grafo->numVertices; i++) {
        printf("V√©rtice %d: Cor %d\n", i, estado.cores[i]);
    }
    printf("N√∫mero crom√°tico ‚â§ %d\n\n", estado.numCores);
    
    return estado.numCores;
}

// Verifica se a colora√ß√£o √© v√°lida
bool verificarColoracao(GrafoNaoDirigido* grafo, int cores[]) {
    for (int u = 0; u < grafo->numVertices; u++) {
        No* atual = grafo->adjacentes[u];
        while (atual != NULL) {
            int v = atual->vertice;
            if (cores[u] == cores[v]) {
                printf("ERRO: V√©rtices adjacentes %d e %d t√™m a mesma cor %d!\n", u, v, cores[u]);
                return false;
            }
            atual = atual->proximo;
        }
    }
    return true;
}

// Algoritmo de Welsh-Powell para colora√ß√£o
int coloracaoWelshPowell(GrafoNaoDirigido* grafo) {
    // Array para armazenar graus dos v√©rtices
    typedef struct {
        int vertice;
        int grau;
    } VerticeGrau;
    
    VerticeGrau vertices[MAX_VERTICES];
    int cores[MAX_VERTICES];
    
    printf("=== Colora√ß√£o Welsh-Powell ===\n");
    
    // Calcula graus
    for (int i = 0; i < grafo->numVertices; i++) {
        vertices[i].vertice = i;
        vertices[i].grau = 0;
        cores[i] = -1;
        
        No* atual = grafo->adjacentes[i];
        while (atual != NULL) {
            vertices[i].grau++;
            atual = atual->proximo;
        }
    }
    
    // Ordena v√©rtices por grau (decrescente) - bubble sort simples
    for (int i = 0; i < grafo->numVertices - 1; i++) {
        for (int j = 0; j < grafo->numVertices - i - 1; j++) {
            if (vertices[j].grau < vertices[j + 1].grau) {
                VerticeGrau temp = vertices[j];
                vertices[j] = vertices[j + 1];
                vertices[j + 1] = temp;
            }
        }
    }
    
    printf("Ordem de colora√ß√£o (por grau decrescente):\n");
    for (int i = 0; i < grafo->numVertices; i++) {
        printf("V√©rtice %d (grau %d)\n", vertices[i].vertice, vertices[i].grau);
    }
    printf("\n");
    
    int numCores = 0;
    bool usado[MAX_VERTICES];
    
    // Colore v√©rtices na ordem de grau decrescente
    for (int i = 0; i < grafo->numVertices; i++) {
        int u = vertices[i].vertice;
        
        // Inicializa cores usadas
        for (int k = 0; k < MAX_VERTICES; k++) {
            usado[k] = false;
        }
        
        // Marca cores usadas pelos adjacentes
        No* atual = grafo->adjacentes[u];
        while (atual != NULL) {
            int v = atual->vertice;
            if (cores[v] != -1) {
                usado[cores[v]] = true;
            }
            atual = atual->proximo;
        }
        
        // Encontra menor cor dispon√≠vel
        int cor;
        for (cor = 0; cor < MAX_VERTICES; cor++) {
            if (!usado[cor]) {
                break;
            }
        }
        
        cores[u] = cor;
        if (cor >= numCores) {
            numCores = cor + 1;
        }
        
        printf("V√©rtice %d: Cor %d\n", u, cor);
    }
    
    printf("N√∫mero de cores usado: %d\n\n", numCores);
    return numCores;
}

// Exemplos e fun√ß√£o main
void exemploComponentesFortementeConexas() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë            EXEMPLO: COMPONENTES FORTEMENTE CONEXAS          ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    GrafoDirigido* grafo = criarGrafoDirigido(5);
    
    // Cria um grafo com m√∫ltiplas SCCs
    adicionarArestaDirigida(grafo, 1, 0);
    adicionarArestaDirigida(grafo, 0, 2);
    adicionarArestaDirigida(grafo, 2, 1);
    adicionarArestaDirigida(grafo, 0, 3);
    adicionarArestaDirigida(grafo, 3, 4);
    
    printf("Grafo dirigido:\n");
    printf("1 ‚Üí 0 ‚Üí 2 ‚Üí 1 (ciclo)\n");
    printf("0 ‚Üí 3 ‚Üí 4\n\n");
    
    encontrarComponentesFortementeConexas(grafo);
    
    free(grafo);
}

void exemploPontesArticulacoes() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë               EXEMPLO: PONTES E ARTICULA√á√ïES                ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    GrafoNaoDirigido* grafo = criarGrafoNaoDirigido(7);
    
    // Cria um grafo com pontes e articula√ß√µes
    adicionarArestaNaoDirigida(grafo, 0, 1);
    adicionarArestaNaoDirigida(grafo, 0, 2);
    adicionarArestaNaoDirigida(grafo, 1, 2);
    adicionarArestaNaoDirigida(grafo, 1, 3);  // Ponte
    adicionarArestaNaoDirigida(grafo, 3, 4);
    adicionarArestaNaoDirigida(grafo, 4, 5);
    adicionarArestaNaoDirigida(grafo, 4, 6);
    adicionarArestaNaoDirigida(grafo, 5, 6);
    
    printf("Estrutura do grafo:\n");
    printf("Tri√¢ngulo: 0-1-2-0\n");
    printf("Ponte: 1-3\n");
    printf("Caminho: 3-4\n");
    printf("Tri√¢ngulo: 4-5-6-4\n\n");
    
    encontrarPontes(grafo);
    encontrarArticulacoes(grafo);
    
    free(grafo);
}

void exemploColoracao() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                  EXEMPLO: COLORA√á√ÉO                         ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    GrafoNaoDirigido* grafo = criarGrafoNaoDirigido(5);
    
    // Cria um grafo que requer m√∫ltiplas cores
    adicionarArestaNaoDirigida(grafo, 0, 1);
    adicionarArestaNaoDirigida(grafo, 0, 2);
    adicionarArestaNaoDirigida(grafo, 1, 2);
    adicionarArestaNaoDirigida(grafo, 1, 3);
    adicionarArestaNaoDirigida(grafo, 2, 3);
    adicionarArestaNaoDirigida(grafo, 3, 4);
    
    printf("Estrutura do grafo:\n");
    printf("Clique K4: 0-1-2-3 (todos conectados)\n");
    printf("Extens√£o: 3-4\n\n");
    
    printf("Comparando algoritmos de colora√ß√£o:\n\n");
    
    int cores1 = coloracaoGulosa(grafo);
    int cores2 = coloracaoWelshPowell(grafo);
    
    printf("Resumo:\n");
    printf("‚Ä¢ Colora√ß√£o gulosa: %d cores\n", cores1);
    printf("‚Ä¢ Welsh-Powell: %d cores\n", cores2);
    printf("‚Ä¢ N√∫mero crom√°tico te√≥rico (clique K4): 4 cores\n\n");
    
    free(grafo);
}

int main() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë              ALGORITMOS DE GRAFOS AVAN√áADOS                 ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    exemploComponentesFortementeConexas();
    printf("\n");
    exemploPontesArticulacoes();
    printf("\n");
    exemploColoracao();
    
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                     RESUMO TE√ìRICO                          ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    printf("üìä COMPLEXIDADES:\n");
    printf("‚Ä¢ Tarjan (SCCs): O(V + E)\n");
    printf("‚Ä¢ Pontes e Articula√ß√µes: O(V + E)\n");
    printf("‚Ä¢ Colora√ß√£o Gulosa: O(V¬≤)\n");
    printf("‚Ä¢ Welsh-Powell: O(V¬≤ + V log V)\n\n");
    
    printf("üéØ APLICA√á√ïES:\n");
    printf("‚Ä¢ SCCs: An√°lise de depend√™ncias, detec√ß√£o de deadlocks\n");
    printf("‚Ä¢ Pontes: Redes cr√≠ticas, pontos de falha\n");
    printf("‚Ä¢ Articula√ß√µes: An√°lise de vulnerabilidade\n");
    printf("‚Ä¢ Colora√ß√£o: Aloca√ß√£o de registradores, scheduling\n\n");
    
    printf("‚ö° PROPRIEDADES:\n");
    printf("‚Ä¢ SCCs formam um DAG quando contra√≠das\n");
    printf("‚Ä¢ Pontes conectam diferentes componentes biconexas\n");
    printf("‚Ä¢ Articula√ß√µes aumentam n√∫mero de componentes se removidas\n");
    printf("‚Ä¢ Colora√ß√£o √© NP-completo, algoritmos s√£o heur√≠sticos\n");
    
    return 0;
}
```

## An√°lise Detalhada dos Algoritmos

### Algoritmo de Tarjan (SCCs)
- **Princ√≠pio:** DFS com pilha e valores `low`
- **Invariante:** `low[u]` = menor tempo de descoberta alcan√ß√°vel de u
- **Detec√ß√£o:** SCC encontrada quando `low[u] == descoberta[u]`

### Algoritmo de Pontes
- **Condi√ß√£o:** Aresta (u,v) √© ponte se `low[v] > descoberta[u]`
- **Significa:** N√£o h√° aresta de retorno que "pule" sobre (u,v)
- **Aplica√ß√£o:** Identifica√ß√£o de conex√µes cr√≠ticas

### Algoritmo de Articula√ß√µes
- **Caso 1:** Raiz da DFS com m√∫ltiplos filhos
- **Caso 2:** `low[v] >= descoberta[u]` para n√£o-raiz
- **Intui√ß√£o:** Remo√ß√£o desconecta componentes

### Colora√ß√£o de Grafos
- **Problema:** NP-completo para colora√ß√£o √≥tima
- **Heur√≠sticas:** Gulosa, Welsh-Powell, algoritmos evolutivos
- **Limitante:** Œî + 1 cores (Œî = grau m√°ximo)

## Aplica√ß√µes Avan√ßadas

### 1. An√°lise de Redes Sociais
- **SCCs:** Identifica√ß√£o de grupos fortemente conectados
- **Pontes:** Usu√°rios que conectam comunidades diferentes
- **Colora√ß√£o:** Classifica√ß√£o de usu√°rios em grupos

### 2. An√°lise de Sistemas
- **SCCs:** Detec√ß√£o de depend√™ncias circulares em software
- **Articula√ß√µes:** Identifica√ß√£o de componentes cr√≠ticos
- **Colora√ß√£o:** Aloca√ß√£o de recursos sem conflitos

### 3. Bioinform√°tica
- **SCCs:** Redes de regula√ß√£o g√™nica
- **Pontes:** Conex√µes evolutivas cr√≠ticas
- **Colora√ß√£o:** Classifica√ß√£o de prote√≠nas

### 4. Redes de Transporte
- **Pontes:** Identifica√ß√£o de gargalos
- **Articula√ß√µes:** Pontos cr√≠ticos de infraestrutura
- **Colora√ß√£o:** Aloca√ß√£o de rotas sem interfer√™ncia
    